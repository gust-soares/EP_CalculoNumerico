# -*- coding: utf-8 -*-
"""EP1 - BMAC.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1V3rlBec29s8fXxwBaaPb_D3toQCQ7Uck

EP1 - MAP2220 - Fórmulas de Integração Numérica de Gauss e Integrais Duplas
 - Raphael Cibulka / NUSP:                11261465
 - Guilherme Barbosa / NUSP:              11261681
 - Gustavo Soares / NUSP:                 11261812
"""

###### Guilherme Barbosa dos Santos 11261681
###### Raphael De Souza Cibulka 11261465
###### Gustavo Soares da Silva Oliveira 11261812

import numpy as np
import copy 
import matplotlib.pyplot as plt
from mpl_toolkits import mplot3d
from mpl_toolkits.mplot3d.art3d import Poly3DCollection, Line3DCollection
   
def d(x, exemplo):                                     ##### função d(x) do limite superior da integral interna

    if exemplo == 1.1:                                 ### serve para determinar d(x) dado um x para cada exemplo
        return 1.0
    if exemplo == 1.2:
        return 1.0 - x
    if exemplo == 2.1:
        return 1-(x**2)
    if exemplo == 2.2:
        return np.sqrt(1-x)
    if exemplo == 3.1 or exemplo == 3.2:
        return x**2
    if exemplo == 4.1:
        return np.sqrt(1-x**2)
    if exemplo == 4.2:
        return np.exp(-(x**2))

              
def c(x, exemplo):                    ## mesma função de d(x), só que para o limite inferior da integral interna

    if exemplo == 1.1 or exemplo == 1.2 or exemplo == 2.1 or exemplo == 2.2 or exemplo == 4.1 or exemplo == 4.2:
        return 0.0
    if exemplo == 3.1 or exemplo == 3.2:
        return x**3
            
        
def f(x, y, exemplo):                    ## cálculo de f(x,y) para cada exemplo

    if exemplo == 1.1 or exemplo == 2.1 or exemplo == 2.2:
        return 1.0  
    if exemplo == 1.2:
        return 1.0 - x - y 
    if exemplo == 3.1:
        return np.exp(y/x) 
    if exemplo == 3.2:
        return np.sqrt(((y**2/x**4)*np.exp(2*y/x)) + (1) + (np.exp(2*y/x)*(1/x**2)))
    if exemplo == 4.1 or exemplo == 4.2:
        return y 
        
def nos (indice, n):                                          ## a função nos retorna um valor de xi dado o numero de nós (n) e um indice 
                                                              ## que indica o numero do nó na formula de gauss
                                                              ## contém os valores de xi dados no enunciado do EP 
    x =  np.zeros(int(n/2), dtype=np.double)
    
    if n == 6:
        x[0] = 0.2386191860831969086305017
        x[1] = 0.6612093864662645136613996
        x[2] = 0.9324695142031520278123016
        if indice < 4:
            return -1*x[(-indice)+3]
        else:
            return x[(indice-4)]
    
    if n == 8:
        x[0] = 0.1834346424956498049394761
        x[1] = 0.5255324099163289858177390
        x[2] = 0.7966664774136267395915539
        x[3] = 0.9602898564975362316835609
        if indice < 5:
                return -1*x[(-indice)+4]
        else:
                return x[(indice-5)]
                   
    if n == 10:
        x[0] = 0.1488743389816312108848260
        x[1] = 0.4333953941292471907992659
        x[2] = 0.6794095682990244062343274
        x[3] = 0.8650633666889845107320967
        x[4] = 0.9739065285171717200779640
        if indice < 6:
                return -1*x[(-indice)+5]
        else:
                return x[(indice-6)]


def pesos (indice, n):                                ## a função pesos retorna um valor de wi dado o numero de nós (n) e um indice 
                                                      ## que indica o numero do peso na formula de gauss 
                                                      ## contém os valores de wi dados no enunciado do EP 
    w =  np.zeros(int(n/2), dtype=np.double)
    
    if n == 6:
        w[0] = 0.4679139345726910473898703
        w[1] = 0.3607615730481386075698335 
        w[2] = 0.1713244923791703450402961
        if indice < 4:
            return w[(-indice)+3]
        else:
            return w[(indice-4)]
    
    if n == 8:
        w[0] = 0.3626837833783619829651504 
        w[1] = 0.3137066458778872873379622  
        w[2] = 0.2223810344533744705443560
        w[3] = 0.1012285362903762591525314
        if indice < 5:
                return w[(-indice)+4]
        else:
                return w[(indice-5)]
                   
    if n == 10:
        w[0] = 0.2955242247147528701738930 
        w[1] = 0.2692667193099963550912269
        w[2] = 0.2190863625159820439955349 
        w[3] = 0.1494513491505805931457763 
        w[4] = 0.0666713443086881375935688
        if indice < 6:
                return w[(-indice)+5]
        else:
                return w[(indice-6)] 
                
def double_gauss_quadrature(b, a, n, exemplo):                                                                                            ### esta função é a principal do programa, executa as iterações
                                                                                                                                          ## para ambas as integrais
    h1 = (b-a)/2 
    h2 =(b+a)/2
    I = 0.0                         ### aproximação da integral dupla
    for i in range(1, n+1):         ### loop para a integral externa
        FX = 0.0                    ### para cada nó considerado, calcular a integral interna e armazenar neste contador   
        x = h1*nos(i, n) + h2       ### transporte linear dos valores dos nós para intervalos [a,b]
        d1 = d(x, exemplo)          ###função d(x) do limite superior da integral interna
        c1 = c(x, exemplo)          ###função c(x) do limite inferior da integral interna
        k1 = (d1-c1)/2              
        k2 = (d1+c1)/2
        for j in range(1, n+1):       ### loop para integral interna
            y = k1*nos(j,n) + k2      ###transporte linear dos valores dos nós para intervalos [c(xi), d(xi)]
            Q = f(x,y,exemplo)        ###cálculo da função f(x,y)
            FX = FX + pesos(j,n)*Q   
            
        I = I + k1*pesos(i,n)*FX     ###a cada nó do loop da integral externa considerada, deve-se somar o valor obtido na interna
        
    return I*h1
            
            
print("inicio do programa")
teste = input('Qual exemplo deseja realizar? (1, 2, 3 ou 4?)' )  ##usuario escolhe qual teste realizar

if teste == '1':
    desejo = input('Gostaria de ver os resultados do cubo, do tetraedro ou ambos? (cubo, tetraedro, ambos)' ) ##escolha da figura no exemplo 1
    if desejo == 'cubo':
    
        # eixos
        axes = [1, 1, 1]
  
        # dados
        data = np.ones(axes, dtype=bool)
  
        # opacidade
        alpha = 0.9
  
        # cores
        colors = np.empty(axes + [4], dtype=np.float32)
        colors[:] = [1, 0, 0, alpha]  # red
        
        # Plot figure
        fig = plt.figure()
        ax = fig.add_subplot(111, projection='3d')
        
        # Voxels is used to customizations of the
        # sizes, positions and colors.
        ax.voxels(data, facecolors=colors)
        plt.show()
        plt.close()
        for i in range(1,4):
            teste = double_gauss_quadrature(1.0, 0.0, 2*i+4, 1.1)
            print('valor obtido por integração a partir de',2*i+4,'nós é:', teste)
        print('valor exato = 1.0')
        
    if desejo == 'tetraedro': 
    
        fig = plt.figure()
        ax = fig.add_subplot(111, projection='3d')

        # vertices do tetraedro
        v = np.array([[0, 0, 0], [1, 0, 0], [0, 1, 0],  [0, 0, 1]])
        ax.scatter3D(v[:, 0], v[:, 1], v[:, 2])

        # lista de vértices da piramide
        verts = [ [v[0],v[1],v[2]], [v[0],v[1],v[3]], [v[0],v[2],v[3]], [v[1],v[2],v[3]] ]

        # plot lados
        ax.add_collection3d(Poly3DCollection(verts,facecolors='cyan', linewidths=1, edgecolors='r', alpha=.9))
        plt.show()
        
        for i in range(1,4):
            teste = double_gauss_quadrature(1.0, 0.0, 2*i+4, 1.2)  ### a chamada desta função gera as aproximações desejadas
            print('valor obtido por integração a partir de',2*i+4,'nós é:', teste)
        print('valor exato = 1/6')
        
    if desejo == 'ambos': 
        print('para o cubo:')
        for i in range(1,4):
            teste = double_gauss_quadrature(1.0, 0.0, 2*i+4, 1.1)
            print('valor obtido por integração a partir de',2*i+4,'nós é:', teste)
        print('valor exato = 1.0')
        
        print('para o tetraedro:')
        for i in range(1,4):
            teste = double_gauss_quadrature(1.0, 0.0, 2*i+4, 1.2)
            print('valor obtido por integração a partir de',2*i+4,'nós é:', teste)
        print('valor exato = 1/6')
        
if teste == '2':
    print('para a primeita integral:')
    for i in range(1,4):
        teste = double_gauss_quadrature(1.0, 0.0, 2*i+4, 2.1)
        print('valor obtido por integração a partir de',2*i+4,'nós é:', teste)
    print('valor exato = 2/3')
    
    print('para a segunda integral:')
    for i in range(1,4):
        teste = double_gauss_quadrature(1.0, 0.0, 2*i+4, 2.2)
        print('valor obtido por integração a partir de',2*i+4,'nós é:', teste)
    print('valor exato = 2/3')

if teste == '3':
    ###plot do domínio de integração do exemplo 3  
    x = np.arange(0.1, 0.51, 0.01) 
    ##intervalo de y
    plt.plot(x, x**2, 'red')  
    plt.plot(x, x**3, 'red')
    
    y = np.arange(0.001, 0.011, 0.001)
    aux = np.array([0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1])
    plt.plot(aux, y, 'red')
    
    y = np.arange(0.125, 0.375, 0.125)
    aux = np.array([0.5, 0.5])
    plt.plot(aux, y, 'red')
    plt.title('Domínio de integração')
    plt.xlabel('x')
    plt.ylabel('y')
    plt.text(0.30, 0.11, r'$x^2$', fontsize=15)
    plt.text(0.35, 0.02, r'$x^3$', fontsize=15)
    plt.show()
    
    print('Para o volume:')
    for i in range(1,4):
        teste = double_gauss_quadrature(0.5, 0.1, 2*i+4, 3.1)
        print('valor obtido por integração a partir de',2*i+4,'nós é:', teste)
        
    print('Para a área:')
    for i in range(1,4):
        teste = double_gauss_quadrature(0.5, 0.1, 2*i+4, 3.2)
        print('valor obtido por integração a partir de',2*i+4,'nós é:', teste)
    
if teste == '4':
    
    print('Volume da calota:')
    for i in range(1,4):
        teste = double_gauss_quadrature(1, 0.75, 2*i+4, 4.1)
        teste = np.pi*2*teste
        print('valor obtido por integração a partir de',2*i+4,'nós é:', teste)
    print('Volume do sólido de revolução:')
    for i in range(1,4):
        teste = double_gauss_quadrature(1, -1, 2*i+4, 4.2)
        teste = np.pi*2*teste
        print('valor obtido por integração a partir de',2*i+4,'nós é:', teste)

print('fim do programa')